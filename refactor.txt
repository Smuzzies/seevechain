# VeChain Visualizer Refactor: Simplified Approach

## Project Overview
A real-time VeChain blockchain visualizer that displays transactions, VTHO burn statistics, and contract activities in a simple, efficient manner. The application will process blockchain data in real-time, store it in a lightweight database, and present it through an intuitive interface featuring a dynamic starfield visualization where transactions appear as interactive circles.

## Core Requirements
1. Real-time blockchain data processing
2. Efficient storage of blockchain data
3. Responsive visualizations
4. Self-hosted solution on Linux
5. Interactive starfield visualization of transactions

## Simplified Technology Stack

### Backend & Frontend
- **Framework**: Next.js
  - Justification: All-in-one solution that handles both frontend and backend, with built-in API routes and server-side rendering.

### Database
- **Database**: SQLite3
  - Justification: Lightweight, file-based database that requires minimal setup and maintenance.

### Additional Libraries
- **Blockchain Interaction**: vechain-thor (npm)
  - For interacting with VeChain nodes
  
- **Real-time Updates**: Socket.IO
  - For pushing real-time updates to connected clients
  
- **Visualization**: 
  - Three.js or PixiJS for the starfield visualization
  - Chart.js for statistical charts
  
- **Styling**: Tailwind CSS
  - For quick and consistent styling
  
- **Animation**: GSAP (GreenSock Animation Platform)
  - For smooth animations and transitions in the starfield

## Application Structure

### Core Components

1. **Block Processor**
   - Connects to VeChain node
   - Retrieves new blocks as they are created
   - Processes transactions and clauses
   - Stores data in SQLite database
   - Emits events for real-time updates

2. **Web Interface**
   - Starfield visualization of real-time transactions
   - Dashboard with transaction statistics
   - Charts for VTHO burn and transaction statistics
   - Contract activity visualization
   - Transaction details view

### Database Schema

1. **blocks**
   ```sql
   CREATE TABLE blocks (
     id TEXT PRIMARY KEY,
     number INTEGER NOT NULL UNIQUE,
     timestamp INTEGER NOT NULL,
     gas_used INTEGER NOT NULL,
     signer TEXT NOT NULL
   );
   ```

2. **transactions**
   ```sql
   CREATE TABLE transactions (
     id TEXT PRIMARY KEY,
     block_number INTEGER NOT NULL,
     timestamp INTEGER NOT NULL,
     origin TEXT NOT NULL,
     gas INTEGER NOT NULL,
     gas_price_coef INTEGER NOT NULL,
     gas_used INTEGER NOT NULL,
     vtho_burn REAL NOT NULL,
     vtho_burn_usd REAL NOT NULL,
     clauses_count INTEGER NOT NULL,
     reverted BOOLEAN DEFAULT FALSE,
     FOREIGN KEY (block_number) REFERENCES blocks(number)
   );
   ```

3. **clauses**
   ```sql
   CREATE TABLE clauses (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     transaction_id TEXT NOT NULL,
     to_address TEXT,
     value TEXT,
     data TEXT,
     type TEXT,
     contract TEXT,
     vtho_burn REAL NOT NULL,
     vtho_burn_usd REAL NOT NULL,
     transfer_token TEXT,
     transfer_amount REAL,
     transfer_sender TEXT,
     transfer_recipient TEXT,
     reverted BOOLEAN DEFAULT FALSE,
     FOREIGN KEY (transaction_id) REFERENCES transactions(id)
   );
   ```

4. **daily_stats**
   ```sql
   CREATE TABLE daily_stats (
     day TEXT PRIMARY KEY,
     transactions_count INTEGER NOT NULL,
     clauses_count INTEGER NOT NULL,
     vtho_burn REAL NOT NULL,
     vtho_burn_usd REAL NOT NULL,
     top_contracts TEXT NOT NULL
   );
   ```

5. **settings**
   ```sql
   CREATE TABLE settings (
     key TEXT PRIMARY KEY,
     value TEXT NOT NULL,
     description TEXT
   );
   ```

### Key Functions

1. **Block Processing**
   - Function to connect to VeChain node
   - Function to subscribe to new blocks
   - Function to process transactions and clauses
   - Function to calculate VTHO burn

2. **Data Storage**
   - Function to save blocks to database
   - Function to save transactions to database
   - Function to save clauses to database
   - Function to update daily statistics

3. **Real-time Updates**
   - Function to emit new block events
   - Function to emit new transaction events
   - Function to handle client connections

4. **Data Retrieval**
   - Function to get latest blocks
   - Function to get transaction details
   - Function to get daily statistics
   - Function to get top contracts

5. **Visualization**
   - Function to initialize starfield
   - Function to add transaction circles to starfield
   - Function to animate transaction circles (fade in/out)
   - Function to handle circle click events (redirect to VeChainStats)
   - Function to render VTHO burn charts
   - Function to render contract activity

6. **Settings Management**
   - Function to load settings from database
   - Function to update settings
   - Function to apply settings to visualization

## Starfield Visualization

### Core Concept
The main visualization will be an interactive starfield where each transaction appears as a circle. The size and appearance of each circle will be determined by the amount of VTHO burned in the transaction.

### Key Features

1. **Transaction Circles**
   - Size proportional to VTHO burn amount
   - Color coding based on transaction type or contract
   - Fade-in animation when a new transaction appears
   - Fade-out animation after a configurable duration
   - Clickable to redirect to VeChainStats transaction page

2. **Circle Content**
   - Transaction ID (shortened)
   - VTHO burn amount
   - Number of clauses
   - Contract name (if known)
   - Small icon representing transaction type

3. **Interaction**
   - Hover to see more details
   - Click to open transaction on VeChainStats
   - Optional zoom in/out functionality
   - Pause/resume animation

4. **Background**
   - Subtle star-like particles moving slowly
   - Gradient background that can be customized
   - Optional grid lines

### Animation Flow
1. New transaction detected
2. Circle appears with fade-in animation (configurable duration)
3. Circle remains visible for a configurable duration
4. Circle fades out (configurable duration)
5. Circle is removed from the DOM

### Configurable Settings
All aspects of the visualization will be configurable through the settings system:

- **Circle Appearance**
  - Base size
  - Size multiplier based on VTHO burn
  - Minimum and maximum size
  - Color schemes
  - Opacity
  - Border style

- **Animation**
  - Fade-in duration
  - Display duration
  - Fade-out duration
  - Movement patterns
  - Animation speed

- **Starfield**
  - Background color/gradient
  - Star density
  - Star size
  - Star movement speed

- **Performance**
  - Maximum number of visible transactions
  - Rendering quality
  - Frame rate limit

## Settings System

### Configuration File
A central `settings.js` file will contain default values for all configurable aspects of the application:

```javascript
// settings.js
export const defaultSettings = {
  // Starfield settings
  starfield: {
    backgroundColor: '#0a0a2a',
    starDensity: 100,
    starSize: { min: 1, max: 3 },
    starSpeed: 0.5,
  },
  
  // Transaction circle settings
  transactionCircles: {
    baseSize: 30,
    vthoMultiplier: 0.5,
    minSize: 20,
    maxSize: 150,
    fadeInDuration: 1000,
    displayDuration: 5000,
    fadeOutDuration: 2000,
    defaultColor: '#3498db',
    contractColors: {
      // Known contract addresses and their colors
      '0xb81e9c5f9644dec9e5e3cac86b4461a222072302': '#e74c3c', // VeChain Node
      // ... more contracts
    },
  },
  
  // Performance settings
  performance: {
    maxVisibleTransactions: 100,
    renderQuality: 'high', // 'low', 'medium', 'high'
    frameRateLimit: 60,
  },
  
  // Data settings
  data: {
    refreshInterval: 5000,
    historyLength: 100,
  },
  
  // External links
  externalLinks: {
    veChainStatsBaseUrl: 'https://vechainstats.com/transaction/',
  },
};
```

### Database Storage
Settings will be stored in the database to allow for persistence and runtime changes:

```javascript
// Initialize settings in database
async function initializeSettings() {
  const db = await openDatabase();
  const settings = await db.get('SELECT * FROM settings WHERE key = "appSettings"');
  
  if (!settings) {
    // Store default settings if none exist
    await db.run(
      'INSERT INTO settings (key, value, description) VALUES (?, ?, ?)',
      ['appSettings', JSON.stringify(defaultSettings), 'Main application settings']
    );
    return defaultSettings;
  }
  
  return JSON.parse(settings.value);
}

// Update settings
async function updateSettings(newSettings) {
  const db = await openDatabase();
  await db.run(
    'UPDATE settings SET value = ? WHERE key = "appSettings"',
    [JSON.stringify(newSettings)]
  );
}
```

### Admin Interface
A simple admin interface will allow for adjusting settings without modifying code:

- Settings dashboard with form controls for all configurable options
- Real-time preview of changes
- Save/reset functionality
- Export/import settings as JSON

## Implementation Approach

### 1. Setup Next.js Project
- Create a new Next.js project
- Configure SQLite3 database
- Set up Socket.IO for real-time communication
- Initialize settings system

### 2. Implement Block Processing
- Create a background worker to connect to VeChain node
- Subscribe to new blocks
- Process transactions and clauses
- Store data in SQLite database

### 3. Develop API Routes
- Create API routes for retrieving data
- Implement endpoints for blocks, transactions, and statistics
- Set up WebSocket connection for real-time updates
- Create settings management endpoints

### 4. Build Starfield Visualization
- Implement the starfield background using Three.js or PixiJS
- Create transaction circle component
- Implement animations for circles (fade in/out)
- Add click handlers to redirect to VeChainStats
- Optimize rendering for performance

### 5. Build Frontend Components
- Create dashboard layout
- Implement transaction feed
- Develop charts for statistics
- Build contract activity visualization
- Create settings admin interface

### 6. Optimize for Performance
- Implement efficient database queries
- Use indexes for frequently accessed data
- Implement caching for common queries
- Optimize rendering with requestAnimationFrame
- Add performance monitoring

## Deployment

### Simple Setup
1. Clone repository to Linux server
2. Install Node.js and npm
3. Run `npm install` to install dependencies
4. Set up environment variables
5. Run database migrations
6. Start application with PM2 or similar process manager

### Environment Variables
```
VECHAIN_NODE_URL=https://node-mainnet.vechain.energy
DATABASE_PATH=/path/to/database.sqlite
PORT=3000
NODE_ENV=production
```

### Process Management
Use PM2 to manage the Node.js process:
```
pm2 start npm --name "vechain-visualizer" -- start
```

## Maintenance

### Database Maintenance
- Implement periodic database cleanup
- Create regular backups
- Set up indexes for performance

### Block Synchronization
- Implement a simple mechanism to detect missing blocks
- Create a script to fill gaps in the blockchain data
- Run this script periodically

### Settings Backup
- Implement automatic backup of settings
- Create restore functionality
- Document all available settings

## Conclusion

This simplified approach focuses on creating an engaging and visually appealing VeChain blockchain visualizer without unnecessary complexity. The starfield visualization with transaction circles weighted by VTHO burn will provide an intuitive and interactive way to observe blockchain activity in real-time.

By using Next.js and SQLite3, we can create a performant application that:

1. Processes blockchain data in real-time
2. Stores it efficiently in a lightweight database
3. Visualizes transactions as an interactive starfield
4. Provides an intuitive and responsive user interface
5. Can be easily deployed and maintained on a Linux server
6. Offers extensive customization through a settings system

The application will be able to show:
- Real-time transaction visualization in a starfield
- Interactive transaction circles sized by VTHO burn
- VTHO burn statistics
- Contract activity
- Detailed transaction information

This approach prioritizes visual appeal and user experience while maintaining simplicity and ease of maintenance.
